#pragma once

/*-----------------------------------------------------------------
* jmp_lib.h
* Header file with defines and functions supporting 
* the C language scoring code generated by JMP
*
* NOT required by customer code.
* Required when compiling JMP-generated C language scoring code.
*-----------------------------------------------------------------*/

#include <math.h>
#include <string.h>
#include <stdlib.h>

/*----------------------------------------------------------------
* Missing Value definition
*  In the score function there is only 1 value for a double
*  that signifies a missing value. That special value is in most
*  cases an IEEE "NaN" value or "Not a Number". The value
*  varies according to the system the function is to run on.
*  The byte order for several systems are as follows:
*
*     AIX                    - big endian    - 0xFFFFFE0000000000
*     HP-UX on PA-RISC       - big endian    - 0xFFFFFE0000000000
*     HP-UX on Itanium       - little endian - 0x0000000000FEFFFF
*     Linux for x64 (x86-64) - little endian - 0x0000000000FEFFFF
*     Linux 32-bit (x86)     - little endian - 0x0000000000FEFFFF
*     Solaris on sparc       - big endian    - 0xFFFFFE0000000000
*     Solaris on amd64       - little endian - 0x0000000000FEFFFF
*     Windows                - little endian - 0x0000000000D1FFFF
*
*  Modify the byte specification for MISSING below to fit your target
*  environment's missing value.
*---------------------------------------------------------------*/
/* for Windows (little endian) */
#define WIN_LE_MISSING  (*((double*)"\0\0\0\0\0\xD1\xff\xff"))

/* for UNIX little endian systems */
#define UNX_LE_MISSING  (*((double*)"\0\0\0\0\0\xfe\xff\xff"))

/* for UNIX big endian systems */
#define UNX_BE_MISSING  (*((double*)"\xff\xff\xfe\0\0\0\0"))

/* Set the system specific value of missing  */
#define MISSING  WIN_LE_MISSING

/*-----------------------------------------------------------------
*  Function Prototypes
*-----------------------------------------------------------------*/
int jmp_numeq(double x, double y);
int jmp_is_missing(double x);
int jmp_max_array(int n, double values[]);
int jmp_min_array(int n, double values[]);
double jmp_squish(double x);
double jmp_squash(double x);
//double jmp_exp(double x); // not needed, we already match JMP's implementation
char* strcpy_safe(char *dst, char *src);

/*-----------------------------------------------------------------
* Function Definitions
*----------------------------------------------------------------*/

/*-----------------------------------------------------------------
* return true if the numbers are identical
* using straight comparison;
* replace with a suitable comparison using a value of EPSILON
* appropriate for your domain.
*-----------------------------------------------------------------*/
int jmp_numeq(double x, double y) {
    return x == y;
    /*  return fabs(a - b) < EPSILON; */
}

/*-----------------------------------------------------------------
* return true if the argument represents a missing value
*-----------------------------------------------------------------*/
int jmp_is_missing(double x) {
    return !isfinite(x) || isnan(x) || memcmp(&x, &(MISSING), sizeof(double)) == 0;
}

/*-----------------------------------------------------------------
* return the index of the max value found in an array, 
* or -1 if all are missing
*-----------------------------------------------------------------*/
int jmp_max_array(int len, double lst[]) {
    double maxval = -INFINITY;
    int maxidx = 0;
	int count_miss = 0;
    
	for (int i = 0; i < len; i++) {
		if (jmp_is_missing(lst[i]))
			count_miss++;
		else if (maxval < lst[i]) {
            maxval = lst[i];
            maxidx = i;
        }
    }
    return (count_miss == len) ? -1 : maxidx;
}

/*-----------------------------------------------------------------
* return the index of the min value found in an array
*-----------------------------------------------------------------*/
int jmp_min_array(int len, double lst[]) {
    double minval = INFINITY;
    int minidx = 0;
	int count_miss = jmp_is_missing(minval) ? 1 : 0;

    for (int i = 0; i < len; i++) {
		if (jmp_is_missing(lst[i]))
			count_miss++;
		else if (minval > lst[i]) {
            minval = lst[i];
            minidx = i;
        }
    }
	return (count_miss == len) ? -1 : minidx;
}

/*-----------------------------------------------------------------
* Also known as logist or logistic
*-----------------------------------------------------------------*/
double jmp_squish(double x) {
    return 1.0 / (1.0 + exp(-x));
}

double jmp_squash(double x) {
    return 1.0 / (1.0 + exp(x));
}


/*-----------------------------------------------------------------
* Safe strcpy, com
*-----------------------------------------------------------------*/
char* strcpy_safe(char* dst, char* src) {
    memcpy(dst, src, strlen(src) + 1);
    return dst;
}
